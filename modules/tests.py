import json
from functools import wraps as this_wraps
from itertools import islice, tee
from unittest import TestCase

import regex as re

from modules.cryptography import RC4, DHE
from modules.misc import hex_to_int

with open("tests.json") as f:  # Load test data
    content = f.read()
    content = re.sub(r'//.*\n', '\n', content)  # Remove comments
    TEST_VECTORS = json.loads(content)
del f

# Regular expression pattern used to parse rfc test vectors
STREAMS_REGEX = re.compile('^(DEC +(?P<decOff>\d+) HEX.+):(?P<hex>( +[0-9a-f]+)+)$')


def make_test(function, *args, **kwargs):
    """Wraps a function, setting the arguments without calling it."""

    @this_wraps(function)  # Decorate to make 'stub' act similar to 'function'
    def stub(self):
        return function(self, *args, **kwargs)

    return stub


class TestDHE(TestCase):
    """Tests my DHE (diffie-hellman key exchange) class against rfc5114 test vectors."""

    DHE_VECTORS = TEST_VECTORS['DHE_VECTORS']

    def _test(self, gen, modulo, pvt_a, pub_a, pvt_b, pub_b, secret):
        alice = DHE.test_init(gen, modulo, pvt_a)
        self.assertEqual(alice.public, pub_a, 'Alice public incorrect')
        bob = DHE.test_init(gen, modulo, pvt_b)
        self.assertEqual(bob.public, pub_b, 'Bob public incorrect')
        # Exchange public keys
        alice.update(bob.public)
        bob.update(alice.public)
        # Test equalities
        self.assertEqual(alice.secret, bob.secret, 'Generated different secrets')
        self.assertEqual(alice.secret, secret, 'Alice secret incorrect')
        self.assertEqual(bob.secret, secret, 'Bob secret incorrect')

    for i, vector in enumerate(DHE_VECTORS):
        # Equivalent to "test_vector_i = s._test(...)"
        locals()[f'test_vector_{i}'] = make_test(
            _test,  # Function to make tests from
            hex_to_int(''.join(vector['group']['g'])),  # Arguments to the function
            hex_to_int(''.join(vector['group']['p'])),
            hex_to_int(vector['xA']),
            hex_to_int(''.join(vector['yA'])),
            hex_to_int(vector['xB']),
            hex_to_int(''.join(vector['yB'])),
            hex_to_int(''.join(vector['Z']))
        )


class TestRC4(TestCase):
    """Tests my RC4 stream cipher against rfc6229 test vectors and 3 wikipedia-sourced examples."""
    EXAMPLE_VECTORS = (
        ('Key', 'EB9F7781B734CA72A719', 'Plaintext', 'BBF316E8D940AF0AD3'),
        ('Wiki', '6044DB6D41B7', 'pedia', '1021BF0420'),
        ('Secret', '04D46B053CA87B59', 'Attack at dawn', '45A01F645FC35B383552544B9BF5'),
    )  # https://en.wikipedia.org/wiki/RC4#Test_vectors

    STREAM_VECTORS = tuple(
        {'key': hex_to_int(vec['key'][2:]),  # Decode the key
         'streams': vec['streams']  # Need to decode these as needed
         } for vec in TEST_VECTORS['RC4_VECTORS'])

    def _test_example(self, key: str, expected_stream: bytes, input_plaintext: str, expected_cipher: bytes):
        """Test a simple encryption example."""
        key = RC4.convert_str_key(key)
        self._test_stream(key, 0, expected_stream)  # Test the key produces the expected stream
        stream1, stream2 = tee(RC4.generate(key))  # Two iterators of the generated stream
        # Compare the encrypted values
        cipher = RC4.crypt_str(stream1, input_plaintext)  # Encrypt the plaintext & format
        self.assertEqual(cipher, expected_cipher, 'Cipher-text mismatch')
        # Sanity check; decrypt( encrypt( plain ) ) = plain
        plain = RC4.crypt_bytes(stream2, cipher).decode('utf-8')
        self.assertEqual(plain, input_plaintext, 'Sanity check fail')

    def _test_stream(self, key: tuple, offset: int, expected_stream: bytes):
        """Compare the stream generated by 'key' with the given stream in hex"""
        stream = RC4.generate(key)  # Create a generator
        for _ in range(offset): next(stream)  # Skip the first 'offset' bytes
        stream_values = bytes(islice(stream, 0, len(expected_stream)))  # Get the needed number of bytes
        self.assertEqual(stream_values, expected_stream, 'Stream mismatch')

    def _test_many_streams(self, key: int, streams: tuple):
        """Formats the test vector and passes it to _test_stream()."""
        key = RC4.convert_int_key(key)
        for i, stream in enumerate(streams):
            with self.subTest(f'Stream chunk {i}'):  # Label each subTest in warning outputs
                offset, stream = STREAMS_REGEX.fullmatch(stream).group('decOff', 'hex')
                offset, stream = int(offset), bytes.fromhex(stream)  # Parse & format data.
                self._test_stream(key, offset, stream)  # Pass data to the test.

    """Generate tests per wiki example test vector"""
    for i, (in_key, out_stream, in_plain, out_cipher) in enumerate(EXAMPLE_VECTORS):
        out_stream = bytes.fromhex(out_stream)
        out_cipher = bytes.fromhex(out_cipher)

        # Equivalent to "test_vector_i = s._test_stream(...)"
        locals()[f'test_vector_{i}'] = make_test(
            _test_example,
            in_key, out_stream, in_plain, out_cipher
        )

    """Generate tests per rfc6229 test vector"""
    for i, vector in enumerate(STREAM_VECTORS):
        # Equivalent to "test_vector_i = s._test_stream(...)"
        locals()[f'test_vector_{i}'] = make_test(
            _test_many_streams,
            vector['key'], vector['streams']
        )
